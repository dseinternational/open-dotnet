// Copyright (c) Down Syndrome Education International and Contributors. All Rights Reserved.
// Down Syndrome Education International and Contributors licence this file to you under the MIT license.

using DSE.Open.Values.Generators.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DSE.Open.Values.Generators;

// Examples:
// https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Emitter.cs
// https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs
// https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/gen/Helpers/SourceWriter.cs

public partial class ValueTypesGenerator
{
    private class Emitter
    {
        public static SourceText GenerateValueStruct(ValueTypeSpec spec, Action<Diagnostic> reportDiagnostic)
        {
            var writer = new SourceWriter();

            writer.WriteBlock("""
                              // <auto-generated/>

                              #nullable enable annotations
                              #nullable disable warnings

                              #pragma warning disable CA2225 // Operator overloads have named alternates

                              """);

            writer.WriteLine("using System;");
            writer.WriteLine("using System.ComponentModel;");
            writer.WriteLine("using System.Runtime.CompilerServices;");

            if (spec.EmitToStringFormattableMethod && (spec.UseGetStringSpan || spec.UseGetString))
            {
                writer.WriteLine("using DSE.Open.Runtime.Helpers;");
            }

            if (spec.EmitEnsureNotDefault)
            {
                writer.WriteLine("using DSE.Open.Values;");
            }

            if (spec.EmitUsingSystemGlobalization)
            {
                writer.WriteLine("using System.Globalization;");
            }

            writer.WriteLine();

            // If we don't have a namespace, generate the code in the "default"
            // namespace, either global:: or a different <RootNamespace>
            var hasNamespace = !string.IsNullOrEmpty(spec.Namespace);

            if (hasNamespace)
            {
                writer.WriteBlock($"namespace {spec.Namespace};");
            }

            var parentsCount = 0;

            if (spec.ParentClass is not null)
            {
                var parentClass = spec.ParentClass;

                // Loop through the full parent type hierarchy, starting with the outermost
                while (parentClass is not null)
                {
                    writer.WriteLine($"partial {parentClass.Keyword} {parentClass.Name} {parentClass.Constraints}");
                    writer.WriteLine("{");
                    writer.Indentation++;

                    parentsCount++; // keep track of how many layers deep we are
                    parentClass = parentClass.Child; // repeat with the next child
                }
            }

            writer.WriteLine(
                $"[TypeConverter(typeof({Namespaces.DseOpenValues}.ValueTypeConverter<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>))]");

            writer.WriteLine(
                $"{AccessibilityHelper.GetKeyword(spec.Accessibility)} readonly partial struct {spec.ValueTypeName}");
            writer.WriteLine("{");

            writer.Indentation++;

            if (spec.EmitMaxSerializedCharLength)
            {
                writer.WriteBlock($"public static int MaxSerializedCharLength => {spec.MaxSerializedCharLength};");
            }

            if (spec.EmitValueField)
            {
                writer.WriteBlock($"private readonly {spec.ContainedValueTypeName} {spec.ValueFieldName};");
            }

            if (spec.EmitConstructor)
            {
                writer.WriteLine(
                    $"{spec.ConstructorAccessibilityValue} {spec.ValueTypeName}({spec.ContainedValueTypeName} value, bool skipValidation = false)");

                writer.WriteLine("{");
                writer.Indentation++;

                writer.WriteBlock("""
                                  if (!skipValidation)
                                  {
                                      EnsureIsValidValue(value);
                                  }
                                  """);

                writer.WriteLine($"{spec.ValueFieldName} = value;");

                writer.Indentation--;
                writer.WriteBlock("}");
            }

            if (spec.EmitEnsureIsValidValueMethod)
            {
                writer.WriteBlock($$"""
                                    private static void EnsureIsValidValue({{spec.ContainedValueTypeName}} value)
                                    {
                                        if (!IsValidValue(value))
                                        {
                                            throw new ArgumentOutOfRangeException(nameof(value), value,
                                                $"'{value}' is not a valid {nameof({{spec.ValueTypeName}})} value");
                                        }
                                    }
                                    """);
            }

            if (spec.EmitEnsureNotDefault)
            {
                writer.WriteBlock($$"""
                                    private void EnsureIsNotDefault()
                                    {
                                        UninitializedValueException<{{spec.ValueTypeName}}, {{spec.ContainedValueTypeName}}>.ThrowIfUninitialized(this);
                                    }
                                    """);
            }

            if (spec.EmitTryFromValueMethod)
            {
                writer.WriteBlock($$"""
                                    public static bool TryFromValue({{spec.ContainedValueTypeName}} value, out {{spec.ValueTypeName}} result)
                                    {
                                        if (IsValidValue(value))
                                        {
                                            result = new {{spec.ValueTypeName}}(value, true);
                                            return true;
                                        }

                                        result = default;
                                        return false;
                                    }
                                    """);
            }

            if (spec.EmitFromValueMethod)
            {
                writer.WriteBlock($$"""
                                    public static {{spec.ValueTypeName}} FromValue({{spec.ContainedValueTypeName}} value)
                                    {
                                        EnsureIsValidValue(value);
                                        return new(value, true);
                                    }
                                    """);
            }

            if (spec.EmitExplicitConversionFromContainedTypeMethod)
            {
                writer.WriteBlock($"""
                                   public static explicit operator {spec.ValueTypeName}({spec.ContainedValueTypeName} value)
                                       => FromValue(value);
                                   """);
            }

            if (spec.EmitConvertToMethod)
            {
                writer.WriteBlock($"""
                                   static {spec.ContainedValueTypeName} {Namespaces.DseOpen}.IConvertibleTo<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>.ConvertTo({spec.ValueTypeName} value)
                                       => ({spec.ContainedValueTypeName})value;
                                   """);
            }

            if (spec.EmitImplicitConversionToContainedTypeMethod)
            {
                writer.WriteLine($$"""
                                   public static implicit operator {{spec.ContainedValueTypeName}}({{spec.ValueTypeName}} value)
                                   {
                                   """);

                if (spec.EmitEnsureNotDefault)
                {
                    writer.Indentation++;
                    writer.WriteLine("value.EnsureIsNotDefault();");
                    writer.Indentation--;
                }

                writer.WriteBlock("""
                                      return value._value;
                                  }
                                  """);
            }
            else if (spec.EmitExplicitConversionToContainedType)
            {
                writer.WriteLine($$"""
                                   public static explicit operator {{spec.ContainedValueTypeName}}({{spec.ValueTypeName}} value)
                                   {
                                   """);

                if (spec.EmitEnsureNotDefault)
                {
                    writer.Indentation++;
                    writer.WriteLine("value.EnsureIsNotDefault();");
                    writer.Indentation--;
                }

                writer.WriteBlock("""
                                      return value._value;
                                  }
                                  """);
            }

            writer.WriteBlock("// IEquatable<T>");

            if (spec.EmitEqualsMethod)
            {
                writer.WriteBlock($"public bool Equals({spec.ValueTypeName} other) => _value.Equals(other._value);");
            }

            if (spec.EmitEqualsObjectMethod)
            {
                writer.WriteBlock(
                    $"public override bool Equals(object? obj) => obj is {spec.ValueTypeName} other && Equals(other);");
            }

            if (spec.EmitGetHashCodeMethod)
            {
                writer.WriteLine("""
                                 public override int GetHashCode()
                                 {
                                 """);

                if (spec.EmitEnsureNotDefault)
                {
                    writer.Indentation++;
                    writer.WriteLine("EnsureIsNotDefault();");
                    writer.Indentation--;
                }

                writer.WriteBlock("""
                                      return _value.GetHashCode();
                                  }
                                  """);
            }

            if (spec.EmitEqualityOperators)
            {
                writer.WriteBlock($"// IEqualityOperators<{spec.ValueTypeName}, {spec.ValueTypeName}, bool>");

                writer.WriteBlock($"""
                                   public static bool operator ==({spec.ValueTypeName} left, {spec.ValueTypeName} right) => left.Equals(right);

                                   public static bool operator !=({spec.ValueTypeName} left, {spec.ValueTypeName} right) => !(left == right);
                                   """);
            }

            writer.WriteBlock("// ISpanFormattable");

            if (spec.EmitTryFormatMethod)
            {
                writer.WriteLine("""
                                 public bool TryFormat(
                                     Span<char> destination,
                                     out int charsWritten,
                                     ReadOnlySpan<char> format,
                                     IFormatProvider? provider)
                                 {
                                 """);

                if (spec.EmitEnsureNotDefault)
                {
                    writer.Indentation++;
                    writer.WriteLine("EnsureIsNotDefault();");
                    writer.Indentation--;
                }

                writer.WriteBlock("""
                                      return ((ISpanFormattable)_value).TryFormat(destination, out charsWritten, format, provider);
                                  }
                                  """);

                // TODO: number styles for int, long, etc.?
            }

            writer.WriteBlock("""
                              public bool TryFormat(
                                  Span<char> destination,
                                  out int charsWritten)
                                  => TryFormat(destination, out charsWritten, default, default);
                              """);

            writer.WriteBlock("""
                              public bool TryFormatInvariant(
                                  Span<char> destination,
                                  out int charsWritten,
                                  ReadOnlySpan<char> format)
                                  => TryFormat(destination, out charsWritten, format, System.Globalization.CultureInfo.InvariantCulture);
                              """);

            writer.WriteBlock("""
                              public bool TryFormatInvariant(
                                  Span<char> destination,
                                  out int charsWritten)
                                  => TryFormatInvariant(destination, out charsWritten, default);
                              """);

            if (spec.EmitToStringFormattableMethod)
            {
                writer.WriteLine($$"""
                                   /// <summary>
                                   /// Gets a representation of the <see cref="{{spec.ValueTypeName}}"/> value as a string with formatting options.
                                   /// </summary>
                                   [SkipLocalsInit]
                                   public string ToString(string? format, IFormatProvider? formatProvider)
                                   {
                                   """);

                if (spec.EmitEnsureNotDefault)
                {
                    writer.WriteBlock("    EnsureIsNotDefault();");
                }

                if (spec.UseGetStringSpan)
                {
                    writer.WriteLine("""
                                         char[]? rented = null;

                                         try
                                         {
                                             Span<char> buffer = MemoryThresholds.CanStackalloc<char>(MaxSerializedCharLength)
                                                 ? stackalloc char[MaxSerializedCharLength]
                                                 : (rented = System.Buffers.ArrayPool<char>.Shared.Rent(MaxSerializedCharLength));

                                             _ = TryFormat(buffer, out var charsWritten, format, formatProvider);

                                             return GetString(buffer[..charsWritten]);
                                         }
                                         finally
                                         {
                                             if (rented is not null)
                                             {
                                                 System.Buffers.ArrayPool<char>.Shared.Return(rented);
                                             }
                                         }
                                     """);
                }
                else if (spec.UseGetString)
                {
                    writer.WriteLine("""
                                         char[]? rented = null;

                                         try
                                         {
                                             Span<char> buffer = MemoryThresholds.CanStackalloc<char>(MaxSerializedCharLength)
                                                 ? stackalloc char[MaxSerializedCharLength]
                                                 : (rented = System.Buffers.ArrayPool<char>.Shared.Rent(MaxSerializedCharLength));

                                             _ = TryFormat(buffer, out var charsWritten, format, formatProvider);

                                             return GetString(new string(buffer[..charsWritten]));
                                         }
                                         finally
                                         {
                                             if (rented is not null)
                                             {
                                                 System.Buffers.ArrayPool<char>.Shared.Return(rented);
                                             }
                                         }
                                     """);
                }
                else
                {
                    writer.WriteLine("    return ((IFormattable)_value).ToString(format, formatProvider);");
                }

                writer.WriteBlock("}");

                writer.WriteBlock("""
                                  public string ToStringInvariant(string? format)
                                  {
                                      return ToString(format, System.Globalization.CultureInfo.InvariantCulture);
                                  }
                                  """);

                writer.WriteBlock("""
                                  public string ToStringInvariant()
                                  {
                                      return ToStringInvariant(default);
                                  }
                                  """);
            }

            if (spec.EmitToStringOverrideMethod)
            {
                writer.WriteBlock($$"""
                                    /// <summary>
                                    /// Gets a representation of the {{spec.ValueTypeName}} value as a string with default formatting options.
                                    /// </summary>
                                    /// <returns>
                                    /// A representation of the {{spec.ValueTypeName}} value.
                                    /// </returns>
                                    public override string ToString()
                                    {
                                        return ToString(default, default);
                                    }
                                    """);
            }

            if (spec.EmitParseSpanMethod || spec.EmitTryParseSpanMethod)
            {
                writer.WriteBlock($"// ISpanParsable<{spec.ValueTypeName}>");
            }

            if (spec.EmitParseSpanMethod)
            {
                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
                                       => {Namespaces.DseOpenValues}.ValueParser.Parse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(s, provider);
                                   """);

                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} ParseInvariant(ReadOnlySpan<char> s)
                                       => Parse(s, System.Globalization.CultureInfo.InvariantCulture);
                                   """);
            }

            if (spec.EmitTryParseSpanMethod)
            {
                writer.WriteBlock($"""
                                   public static bool TryParse(
                                       ReadOnlySpan<char> s,
                                       IFormatProvider? provider,
                                       out {spec.ValueTypeName} result)
                                       => {Namespaces.DseOpenValues}.ValueParser.TryParse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(s, provider, out result);
                                   """);

                writer.WriteBlock($"""
                                   public static bool TryParse(
                                       ReadOnlySpan<char> s,
                                       out {spec.ValueTypeName} result)
                                       => TryParse(s, default, out result);
                                   """);

                writer.WriteBlock($"""
                                   public static bool TryParseInvariant(
                                       ReadOnlySpan<char> s,
                                       out {spec.ValueTypeName} result)
                                       => TryParse(s, System.Globalization.CultureInfo.InvariantCulture, out result);
                                   """);
            }

            if (spec.EmitParseStringMethod || spec.EmitTryParseStringMethod)
            {
                writer.WriteBlock($"// IParsable<{spec.ValueTypeName}>");
            }

            if (spec.EmitParseStringMethod)
            {
                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} Parse(string s, IFormatProvider? provider)
                                       => {Namespaces.DseOpenValues}.ValueParser.Parse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(s, provider);
                                   """);

                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} Parse(string s)
                                       => Parse(s, default);
                                   """);

                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} ParseInvariant(string s)
                                       => Parse(s, System.Globalization.CultureInfo.InvariantCulture);
                                   """);
            }

            if (spec.EmitTryParseStringMethod)
            {
                writer.WriteBlock($$"""
                                    public static bool TryParse(
                                        string? s,
                                        IFormatProvider? provider,
                                        out {{spec.ValueTypeName}} result)
                                    {
                                        if (s is null)
                                        {
                                            result = default;
                                            return false;
                                        }

                                        return TryParse(s.AsSpan(), provider, out result);
                                    }
                                    """);

                writer.WriteBlock($"""
                                   public static bool TryParse(
                                       string? s,
                                       out {spec.ValueTypeName} result)
                                       => TryParse(s, default, out result);
                                   """);

                writer.WriteBlock($"""
                                   public static bool TryParseInvariant(
                                       string? s,
                                       out {spec.ValueTypeName} result)
                                       => TryParse(s, System.Globalization.CultureInfo.InvariantCulture, out result);
                                   """);
            }

            if (spec.EmitTryParseSpanNumberStylesMethod)
            {
                writer.WriteBlock($"""
                                   public static bool TryParse(
                                       ReadOnlySpan<char> s,
                                       NumberStyles style,
                                       IFormatProvider? provider,
                                       out {spec.ValueTypeName} result)
                                       // TODO: ***** NumberStyles *****
                                       => {Namespaces.DseOpenValues}.ValueParser.TryParse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(s, provider, out result);
                                   """);
            }

            if (spec.EmitTryParseStringNumberStylesMethod)
            {
                writer.WriteBlock($"""
                                   public static bool TryParse(
                                       string? s,
                                       NumberStyles style,
                                       IFormatProvider? provider,
                                       out {spec.ValueTypeName} result)
                                       // TODO: ***** NumberStyles *****
                                       => {Namespaces.DseOpenValues}.ValueParser.TryParse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(s, provider, out result);
                                   """);
            }

            if (spec.EmitParseSpanNumberStylesMethod)
            {
                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider)
                                       => ({spec.ValueTypeName}){spec.ContainedValueTypeName}.Parse(s, style, provider); // TODO: NumberStyles
                                   """);
            }

            if (spec.EmitParseStringNumberStylesMethod)
            {
                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} Parse(string s, NumberStyles style, IFormatProvider? provider)
                                       => ({spec.ValueTypeName}){spec.ContainedValueTypeName}.Parse(s, style, provider); // TODO: NumberStyles
                                   """);
            }

            if (spec.EmitTryFormatUtf8Method)
            {
                writer.WriteBlock("// IUtf8SpanFormattable");

                writer.WriteBlock("""
                                  public bool TryFormat(
                                      Span<byte> utf8Destination,
                                      out int bytesWritten,
                                      ReadOnlySpan<char> format,
                                      IFormatProvider? provider)
                                      => ((IUtf8SpanFormattable)_value).TryFormat(utf8Destination, out bytesWritten, format, provider);
                                  """);
            }

            if (spec.EmitParseUtf8Method || spec.EmitTryParseUtf8Method)
            {
                writer.WriteBlock($"// IUtf8SpanParsable<{spec.ValueTypeName}>");
            }

            if (spec.EmitParseUtf8Method)
            {
                writer.WriteBlock($"""
                                   public static {spec.ValueTypeName} Parse(
                                       ReadOnlySpan<byte> utf8Source,
                                       IFormatProvider? provider)
                                       => {Namespaces.DseOpenValues}.ValueParser.Parse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(utf8Source, provider);
                                   """);
            }

            if (spec.EmitTryParseUtf8Method)
            {
                writer.WriteBlock($"""
                                   public static bool TryParse(
                                       ReadOnlySpan<byte> utf8Source,
                                       IFormatProvider? provider,
                                       out {spec.ValueTypeName} result)
                                       => {Namespaces.DseOpenValues}.ValueParser.TryParse<{spec.ValueTypeName}, {spec.ContainedValueTypeName}>(utf8Source, provider, out result);
                                   """);
            }

            if (spec is ComparableValueTypeSpec ordinalSpec)
            {
                if (ordinalSpec.EmitCompareToMethod)
                {
                    writer.WriteLine($$"""
                                       public int CompareTo({{spec.ValueTypeName}} other)
                                       {
                                       """);

                    if (spec.EmitEnsureNotDefault)
                    {
                        writer.Indentation++;
                        writer.WriteBlock("EnsureIsNotDefault();");
                        writer.Indentation--;
                    }

                    writer.WriteBlock("""
                                          return _value.CompareTo(other._value);
                                      }
                                      """);
                }

                /*
                if (ordinalSpec.EmitCompareToObjectMethod)
                {
                    writer.WriteLine();
                    writer.WriteLine($$"""
                        public int CompareTo(object? obj) => _value.CompareTo(obj);
                        """);
                }
                */

                if (ordinalSpec.EmitComparisonOperators)
                {
                    writer.WriteBlock($"// IComparisonOperators<{spec.ValueTypeName}, {spec.ValueTypeName}, bool>");

                    writer.WriteBlock($"""
                                       public static bool operator <({spec.ValueTypeName} left, {spec.ValueTypeName} right) => left.CompareTo(right) < 0;

                                       public static bool operator >({spec.ValueTypeName} left, {spec.ValueTypeName} right) => left.CompareTo(right) > 0;

                                       public static bool operator <=({spec.ValueTypeName} left, {spec.ValueTypeName} right) => left.CompareTo(right) <= 0;

                                       public static bool operator >=({spec.ValueTypeName} left, {spec.ValueTypeName} right) => left.CompareTo(right) >= 0;
                                       """);
                }
            }

            if (spec is AddableValueTypeSpec intervalSpec)
            {
                if (intervalSpec.EmitAdditionOperator)
                {
                    writer.WriteBlock(
                        $"// IAdditionOperators<{spec.ValueTypeName}, {spec.ValueTypeName}, {spec.ValueTypeName}>");

                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator +({spec.ValueTypeName} left, {spec.ValueTypeName} right) => ({spec.ValueTypeName})(left._value + right._value);");
                }

                if (intervalSpec.EmitDecrementOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator --({spec.ValueTypeName} value) => ({spec.ValueTypeName})(value._value - 1);");
                }

                if (intervalSpec.EmitIncrementOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator ++({spec.ValueTypeName} value) => ({spec.ValueTypeName})(value._value + 1);");
                }

                if (intervalSpec.EmitSubtractionOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator -({spec.ValueTypeName} left, {spec.ValueTypeName} right) => ({spec.ValueTypeName})(left._value - right._value);");
                }

                if (intervalSpec.EmitUnaryPlusOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator +({spec.ValueTypeName} value) => ({spec.ValueTypeName})(+value._value);");
                }

                if (intervalSpec.EmitUnaryNegationOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator -({spec.ValueTypeName} value) => ({spec.ValueTypeName})(-value._value);");
                }
            }

            if (spec is DivisibleValueTypeGenerationSpec ratioSpec)
            {
                if (ratioSpec.EmitMultiplicationOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator *({spec.ValueTypeName} left, {spec.ValueTypeName} right) => ({spec.ValueTypeName})(left._value * right._value);");
                }

                if (ratioSpec.EmitDivisionOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator /({spec.ValueTypeName} left, {spec.ValueTypeName} right) => ({spec.ValueTypeName})(left._value / right._value);");
                }

                if (ratioSpec.EmitModulusOperator)
                {
                    writer.WriteBlock(
                        $"public static {spec.ValueTypeName} operator %({spec.ValueTypeName} left, {spec.ValueTypeName} right) => ({spec.ValueTypeName})(left._value % right._value);");
                }
            }

            writer.Indentation--;
            writer.WriteBlock("}");

// We need to "close" each of the parent types, so write
// the required number of '}'
            for (var i = 0; i < parentsCount; i++)
            {
                writer.Indentation--;
                writer.WriteBlock("}");
            }

            return writer.ToSourceText();
        }
    }
}
