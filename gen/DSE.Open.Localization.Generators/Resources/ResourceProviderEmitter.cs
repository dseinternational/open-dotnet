// Copyright (c) Down Syndrome Education International and Contributors. All Rights Reserved.
// Down Syndrome Education International and Contributors licence this file to you under the MIT license.

using System.Text;
using DSE.Open.Localization.Generators.Resources.Parsing;

namespace DSE.Open.Localization.Generators.Resources;

internal static class ResourceProviderEmitter
{
    public static string Emit(
        ResourceProviderInformation model,
        IEnumerable<ResourceItem> resourceItems)
    {
        var providerName = model.ProviderName;
        var resourcesName = model.ResourcesName;

        var providerNamespace = model.ProviderNamespace;
        var providerAccessibility = model.ProviderAccessibility;

        var builder = new StringBuilder();

        _ = builder.AppendLine(
            $$"""
              // <auto-generated/>

              #nullable enable

              namespace {{providerNamespace}};

              {{providerAccessibility}} partial class {{providerName}} : global::DSE.Open.Localization.Resources.PackagedLocalizedResourceProvider
              {
                  public static readonly {{providerName}} Default = new();

                  private static readonly {{GlobalTypes.ResourceManager}} s_stringsResourceManager = new(
                      typeof({{resourcesName}}).FullName!,
                      typeof({{resourcesName}}).Assembly);

                  /// <summary>
                  /// Sets the culture for lookups. (For testing.)
                  /// </summary>
                  /// <param name="culture"></param>
                  internal void SetLookupCulture({{GlobalTypes.CultureInfo}}? culture)
                  {
                      LookupCulture = culture;
                  }

                  protected override {{GlobalTypes.ResourceManager}} ResourceManager => s_stringsResourceManager;

              """);

        foreach (var item in resourceItems)
        {
            EmitGetString(item, builder);
        }

        _ = builder.AppendLine("}");

        return builder.ToString();
    }

    private static void EmitGetString(ResourceItem item, StringBuilder builder)
    {
        const string cultureInfoVarName = "cultureInfo";
        const string cultureInfoParameter = $"{GlobalTypes.CultureInfo}? {cultureInfoVarName} = null";

        var key = item.Key;

        _ = builder.AppendLine(
            $"""
                 /// <summary>
                 /// Gets the value of the resource with the key '{key}' for the culture <paramref name="{cultureInfoVarName}"/>.
                 /// </summary>
             """);

        if (item.Holes.Count <= 0)
        {
            _ = builder.AppendLine(
                $$"""
                      public string {{key}}({{cultureInfoParameter}})
                      {
                          return GetString("{{key}}", {{cultureInfoVarName}});
                      }

                  """);

            return;
        }

        List<ParameterDefinition> parameters = [..item.Holes.Select(ParameterDefinition.FromHole)];

        // Call `Distinct` to remove duplicate parameters, if any.
        var methodParameters = parameters
            .Distinct()
            .Select(p => p.ToString())
            .Concat([cultureInfoParameter]);

        _ = builder.AppendLine(
            $$"""
                  public string {{key}}(
                      {{string.Join(",\n        ", methodParameters)}})
                  {
              """);

        var interpolatedString = CreateInterpolatedString(item, parameters);

        _ = builder.AppendLine(
            $"""
                     var format = GetString("{key}", {cultureInfoVarName});
                     return $"{interpolatedString}";
             """);

        _ = builder.AppendLine(
            """
                }

            """);
    }

    private static string CreateInterpolatedString(
        ResourceItem item,
        List<ParameterDefinition> parameters)
    {
        var holes = item.Holes;
        var formatLength = item.FormatLength;

        var builder = new StringBuilder();

        var formatIndex = 0;

        for (var i = 0; i < holes.Count; i++)
        {
            var hole = holes[i];
            var param = parameters[i];

            if (hole.Index > formatIndex)
            {
                // The next hole is preceded by a constant string, positioned
                // from our current index up to, but not including, the `hole`s
                // start index.
                _ = builder.Append(
                    $$"""
                      {format[{{formatIndex}}..{{hole.Index}}]}
                      """);
            }

            _ = builder.Append(
                $$"""
                  {{{param.Name}}}
                  """);

            // Step the format index to the end of the hole.
            formatIndex = hole.Index + hole.Length;

            if (i == holes.Count - 1 && formatIndex < formatLength)
            {
                // Copy the trailing constant string.
                _ = builder.Append(
                    $$"""
                      {format[{{formatIndex}}..]}
                      """);
            }
        }

        return builder.ToString();
    }
}
