// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used

namespace DSE.Open.Globalization
{
    partial struct LanguageTag
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>^((?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?:([A-Za-z]{2,3}(-(?:[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?:[A-Za-z]{4}))?(-(?:[A-Za-z]{2}|[0-9]{3}))?(-(?:[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?:[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?:x(-[A-Za-z0-9]{1,8})+))?)|(?:x(-[A-Za-z0-9]{1,8})+))$</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at the beginning of the string.<br/>
        /// ○ Match with 9 alternative expressions.<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Ee].<br/>
        ///         ○ Match a character in the set [Nn].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match a character in the set [Gg].<br/>
        ///         ○ Match a character in the set [Bb].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match a character in the set [Oo].<br/>
        ///         ○ Match a character in the set [Ee].<br/>
        ///         ○ Match a character in the set [Dd].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Ii].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match with 11 alternative expressions.<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Mm].<br/>
        ///                 ○ Match a character in the set [Ii].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Bb].<br/>
        ///                 ○ Match a character in the set [Nn] exactly 2 times.<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Dd].<br/>
        ///                 ○ Match a character in the set [Ee].<br/>
        ///                 ○ Match a character in the set [Ff].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Uu].<br/>
        ///                 ○ Match a character in the set [Ll].<br/>
        ///                 ○ Match a character in the set [Tt].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Ee].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///                 ○ Match a character in the set [Oo].<br/>
        ///                 ○ Match a character in the set [Cc].<br/>
        ///                 ○ Match a character in the set [Hh].<br/>
        ///                 ○ Match a character in the set [Ii].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Hh].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Kk\u212A].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Kk\u212A].<br/>
        ///                 ○ Match a character in the set [Ll].<br/>
        ///                 ○ Match a character in the set [Ii].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///                 ○ Match a character in the set [Gg].<br/>
        ///                 ○ Match a character in the set [Oo].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Ll].<br/>
        ///                 ○ Match a character in the set [Uu].<br/>
        ///                 ○ Match a character in the set [Xx].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Mm].<br/>
        ///                 ○ Match a character in the set [Ii].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///                 ○ Match a character in the set [Gg].<br/>
        ///                 ○ Match a character in the set [Oo].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Vv].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Jj].<br/>
        ///                 ○ Match a character in the set [Oo].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Pp].<br/>
        ///                 ○ Match a character in the set [Ww].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Tt].<br/>
        ///                 ○ Match with 2 alternative expressions.<br/>
        ///                     ○ Match a sequence of expressions.<br/>
        ///                         ○ Match an empty string.<br/>
        ///                         ○ Match a character in the set [OYoy].<br/>
        ///                     ○ Match a sequence of expressions.<br/>
        ///                         ○ Match an empty string.<br/>
        ///                         ○ Match a character in the set [Uu].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Ss].<br/>
        ///         ○ Match a character in the set [Gg].<br/>
        ///         ○ Match a character in the set [Nn].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match with 2 alternative expressions.<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Bb].<br/>
        ///                 ○ Match a character in the set [Ee].<br/>
        ///                 ○ Match '-'.<br/>
        ///                 ○ Match with 2 alternative expressions.<br/>
        ///                     ○ Match a sequence of expressions.<br/>
        ///                         ○ Match an empty string.<br/>
        ///                         ○ Match a character in the set [Rr].<br/>
        ///                     ○ Match a sequence of expressions.<br/>
        ///                         ○ Match an empty string.<br/>
        ///                         ○ Match a character in the set [Ll].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Cc].<br/>
        ///                 ○ Match a character in the set [Hh].<br/>
        ///                 ○ Match '-'.<br/>
        ///                 ○ Match a character in the set [Dd].<br/>
        ///                 ○ Match a character in the set [Ee].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Aa].<br/>
        ///         ○ Match a character in the set [Rr].<br/>
        ///         ○ Match a character in the set [Tt].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match a character in the set [Ll].<br/>
        ///         ○ Match a character in the set [Oo].<br/>
        ///         ○ Match a character in the set [Jj].<br/>
        ///         ○ Match a character in the set [Bb].<br/>
        ///         ○ Match a character in the set [Aa].<br/>
        ///         ○ Match a character in the set [Nn].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Cc].<br/>
        ///         ○ Match a character in the set [Ee].<br/>
        ///         ○ Match a character in the set [Ll].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match a character in the set [Gg].<br/>
        ///         ○ Match a character in the set [Aa].<br/>
        ///         ○ Match a character in the set [Uu].<br/>
        ///         ○ Match a character in the set [Ll].<br/>
        ///         ○ Match a character in the set [Ii].<br/>
        ///         ○ Match a character in the set [Ss].<br/>
        ///         ○ Match a character in the set [Hh].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Nn].<br/>
        ///         ○ Match a character in the set [Oo].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match with 2 alternative expressions.<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match an empty string.<br/>
        ///                 ○ Match a character in the set [Oo].<br/>
        ///                 ○ Match a character in the set [Kk\u212A].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match an empty string.<br/>
        ///                 ○ Match a character in the set [Yy].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Zz].<br/>
        ///         ○ Match a character in the set [Hh].<br/>
        ///         ○ Match '-'.<br/>
        ///         ○ Match with 4 alternative expressions.<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Gg].<br/>
        ///                 ○ Match a character in the set [Uu].<br/>
        ///                 ○ Match a character in the set [Oo].<br/>
        ///                 ○ Match a character in the set [Yy].<br/>
        ///                 ○ Match a character in the set [Uu].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Hh].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Kk\u212A] exactly 2 times.<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Mm].<br/>
        ///                 ○ Match a character in the set [Ii].<br/>
        ///                 ○ Match with 2 alternative expressions.<br/>
        ///                     ○ Match a character in the set [Nn].<br/>
        ///                     ○ Match a sequence of expressions.<br/>
        ///                         ○ Match a character in the set [Nn].<br/>
        ///                         ○ Match '-'.<br/>
        ///                         ○ Match a character in the set [Nn].<br/>
        ///                         ○ Match a character in the set [Aa].<br/>
        ///                         ○ Match a character in the set [Nn].<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [Xx].<br/>
        ///                 ○ Match a character in the set [Ii].<br/>
        ///                 ○ Match a character in the set [Aa].<br/>
        ///                 ○ Match a character in the set [Nn].<br/>
        ///                 ○ Match a character in the set [Gg].<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match with 3 alternative expressions.<br/>
        ///             ○ Match a sequence of expressions.<br/>
        ///                 ○ Match a character in the set [A-Za-z\u212A] greedily at least 2 and at most 3 times.<br/>
        ///                 ○ Optional (greedy).<br/>
        ///                     ○ Match '-'.<br/>
        ///                     ○ Match a character in the set [A-Za-z\u212A] exactly 3 times.<br/>
        ///                     ○ Loop greedily at most 2 times.<br/>
        ///                         ○ Match '-'.<br/>
        ///                         ○ Match a character in the set [A-Za-z\u212A] exactly 3 times.<br/>
        ///             ○ Match a character in the set [A-Za-z\u212A] exactly 4 times.<br/>
        ///             ○ Match a character in the set [A-Za-z\u212A] greedily at least 5 and at most 8 times.<br/>
        ///         ○ Optional (greedy).<br/>
        ///             ○ Match '-'.<br/>
        ///             ○ Match a character in the set [A-Za-z\u212A] exactly 4 times.<br/>
        ///         ○ Optional (greedy).<br/>
        ///             ○ Match '-'.<br/>
        ///             ○ Match with 2 alternative expressions.<br/>
        ///                 ○ Match a character in the set [A-Za-z\u212A] exactly 2 times.<br/>
        ///                 ○ Match a character in the set [0-9] exactly 3 times.<br/>
        ///         ○ Loop greedily any number of times.<br/>
        ///             ○ Match '-'.<br/>
        ///             ○ Match with 2 alternative expressions.<br/>
        ///                 ○ Match a character in the set [0-9A-Za-z\u212A] greedily at least 5 and at most 8 times.<br/>
        ///                 ○ Match a sequence of expressions.<br/>
        ///                     ○ Match a character in the set [0-9].<br/>
        ///                     ○ Match a character in the set [0-9A-Za-z\u212A] exactly 3 times.<br/>
        ///         ○ Loop greedily any number of times.<br/>
        ///             ○ Match '-'.<br/>
        ///             ○ Match a character in the set [0-9A-WYZa-wyz\u212A].<br/>
        ///             ○ Loop greedily at least once.<br/>
        ///                 ○ Match '-'.<br/>
        ///                 ○ Match a character in the set [0-9A-Za-z\u212A] greedily at least 2 and at most 8 times.<br/>
        ///         ○ Optional (greedy).<br/>
        ///             ○ Match '-'.<br/>
        ///             ○ Match a character in the set [Xx].<br/>
        ///             ○ Loop greedily at least once.<br/>
        ///                 ○ Match '-'.<br/>
        ///                 ○ Match a character in the set [0-9A-Za-z\u212A] greedily at least 1 and at most 8 times.<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match a character in the set [Xx].<br/>
        ///         ○ Loop greedily at least once.<br/>
        ///             ○ Match '-'.<br/>
        ///             ○ Match a character in the set [0-9A-Za-z\u212A] atomically at least 1 and at most 8 times.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.12.21509")]
        private static partial global::System.Text.RegularExpressions.Regex GetValidationRegex() => global::System.Text.RegularExpressions.Generated.GetValidationRegex_0.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the GetValidationRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.12.21509")]
    [SkipLocalsInit]
    file sealed class GetValidationRegex_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly GetValidationRegex_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private GetValidationRegex_0()
        {
            base.pattern = "^((?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?:([A-Za-z]{2,3}(-(?:[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?:[A-Za-z]{4}))?(-(?:[A-Za-z]{2}|[0-9]{3}))?(-(?:[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?:[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?:x(-[A-Za-z0-9]{1,8})+))?)|(?:x(-[A-Za-z0-9]{1,8})+))$";
            base.roptions = RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture;
            base.internalMatchTimeout = TimeSpan.FromMilliseconds(250);
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // The pattern is anchored.  Validate the current position and try to match at it only.
                    if (TryFindNextPossibleStartingPosition(inputSpan) && !TryMatchAtCurrentPosition(inputSpan))
                    {
                        base.runtextpos = inputSpan.Length;
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 2 characters.
                    if (pos <= inputSpan.Length - 2)
                    {
                        // The pattern leads with a beginning (\A) anchor.
                        if (pos == 0)
                        {
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    int alternation_branch = 0;
                    int alternation_branch1 = 0;
                    int alternation_branch2 = 0;
                    int alternation_branch3 = 0;
                    int alternation_branch4 = 0;
                    int alternation_branch5 = 0;
                    int alternation_starting_pos = 0;
                    int alternation_starting_pos1 = 0;
                    int alternation_starting_pos2 = 0;
                    int alternation_starting_pos3 = 0;
                    int alternation_starting_pos4 = 0;
                    int alternation_starting_pos5 = 0;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int charloop_starting_pos1 = 0, charloop_ending_pos1 = 0;
                    int charloop_starting_pos2 = 0, charloop_ending_pos2 = 0;
                    int charloop_starting_pos3 = 0, charloop_ending_pos3 = 0;
                    int charloop_starting_pos4 = 0, charloop_ending_pos4 = 0;
                    int loop_iteration = 0;
                    int loop_iteration1 = 0;
                    int loop_iteration2 = 0;
                    int loop_iteration3 = 0;
                    int loop_iteration4 = 0;
                    int loop_iteration5 = 0;
                    int loop_iteration6 = 0;
                    int loop_iteration7 = 0;
                    int loop_iteration8 = 0;
                    int loop_iteration9 = 0;
                    int stackpos = 0;
                    ulong charMinusLowUInt64;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at the beginning of the string.
                    if (pos != 0)
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match with 9 alternative expressions.
                    //{
                        alternation_starting_pos = pos;
                        
                        // Branch 0
                        //{
                            if ((uint)slice.Length < 9 ||
                                !slice.StartsWith("en-gb-oed", StringComparison.OrdinalIgnoreCase)) // Match the string "en-gb-oed" (ordinal case-insensitive)
                            {
                                goto AlternationBranch;
                            }
                            
                            alternation_branch = 0;
                            pos += 9;
                            slice = inputSpan.Slice(pos);
                            goto AlternationMatch;
                            
                            AlternationBranch:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 1
                        //{
                            if ((uint)slice.Length < 2 ||
                                !slice.StartsWith("i-", StringComparison.OrdinalIgnoreCase)) // Match the string "i-" (ordinal case-insensitive)
                            {
                                goto AlternationBranch1;
                            }
                            
                            // Match with 11 alternative expressions.
                            //{
                                alternation_starting_pos1 = pos;
                                
                                // Branch 0
                                //{
                                    if ((uint)slice.Length < 5 ||
                                        !slice.Slice(2).StartsWith("ami", StringComparison.OrdinalIgnoreCase)) // Match the string "ami" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch2;
                                    }
                                    
                                    alternation_branch1 = 0;
                                    pos += 5;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch2:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 1
                                //{
                                    if ((uint)slice.Length < 5 ||
                                        !slice.Slice(2).StartsWith("bnn", StringComparison.OrdinalIgnoreCase)) // Match the string "bnn" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch3;
                                    }
                                    
                                    alternation_branch1 = 1;
                                    pos += 5;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch3:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 2
                                //{
                                    if ((uint)slice.Length < 9 ||
                                        !slice.Slice(2).StartsWith("default", StringComparison.OrdinalIgnoreCase)) // Match the string "default" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch4;
                                    }
                                    
                                    alternation_branch1 = 2;
                                    pos += 9;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch4:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 3
                                //{
                                    if ((uint)slice.Length < 10 ||
                                        !slice.Slice(2).StartsWith("enochian", StringComparison.OrdinalIgnoreCase)) // Match the string "enochian" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch5;
                                    }
                                    
                                    alternation_branch1 = 3;
                                    pos += 10;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch5:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 4
                                //{
                                    if ((uint)slice.Length < 5 ||
                                        !slice.Slice(2).StartsWith("ha", StringComparison.OrdinalIgnoreCase) || // Match the string "ha" (ordinal case-insensitive)
                                        ((((ch = slice[4]) | 0x20) != 'k') & (ch != 'K'))) // Match a character in the set [Kk\u212A].
                                    {
                                        goto AlternationBranch6;
                                    }
                                    
                                    alternation_branch1 = 4;
                                    pos += 5;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch6:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 5
                                //{
                                    if ((uint)slice.Length < 9 ||
                                        ((((ch = slice[2]) | 0x20) != 'k') & (ch != 'K')) || // Match a character in the set [Kk\u212A].
                                        !slice.Slice(3).StartsWith("lingon", StringComparison.OrdinalIgnoreCase)) // Match the string "lingon" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch7;
                                    }
                                    
                                    alternation_branch1 = 5;
                                    pos += 9;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch7:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 6
                                //{
                                    if ((uint)slice.Length < 5 ||
                                        !slice.Slice(2).StartsWith("lux", StringComparison.OrdinalIgnoreCase)) // Match the string "lux" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch8;
                                    }
                                    
                                    alternation_branch1 = 6;
                                    pos += 5;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch8:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 7
                                //{
                                    if ((uint)slice.Length < 7 ||
                                        !slice.Slice(2).StartsWith("mingo", StringComparison.OrdinalIgnoreCase)) // Match the string "mingo" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch9;
                                    }
                                    
                                    alternation_branch1 = 7;
                                    pos += 7;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch9:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 8
                                //{
                                    if ((uint)slice.Length < 8 ||
                                        !slice.Slice(2).StartsWith("navajo", StringComparison.OrdinalIgnoreCase)) // Match the string "navajo" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch10;
                                    }
                                    
                                    alternation_branch1 = 8;
                                    pos += 8;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch10:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 9
                                //{
                                    if ((uint)slice.Length < 5 ||
                                        !slice.Slice(2).StartsWith("pwn", StringComparison.OrdinalIgnoreCase)) // Match the string "pwn" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch11;
                                    }
                                    
                                    alternation_branch1 = 9;
                                    pos += 5;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch1;
                                    
                                    AlternationBranch11:
                                    pos = alternation_starting_pos1;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 10
                                //{
                                    // Match a character in the set [Tt].
                                    if ((uint)slice.Length < 3 || ((slice[2] | 0x20) != 't'))
                                    {
                                        goto AlternationBranch1;
                                    }
                                    
                                    // Match with 2 alternative expressions.
                                    //{
                                        if ((uint)slice.Length < 4)
                                        {
                                            goto AlternationBranch1;
                                        }
                                        
                                        switch (slice[3])
                                        {
                                            case 'A' or 'a':
                                                
                                                // Match a character in the set [OYoy].
                                                if ((uint)slice.Length < 5 || ((long)((0x8020000080200000UL << (int)(charMinusLowUInt64 = (uint)slice[4] - 'O')) & (charMinusLowUInt64 - 64)) >= 0))
                                                {
                                                    goto AlternationBranch1;
                                                }
                                                
                                                pos += 5;
                                                slice = inputSpan.Slice(pos);
                                                break;
                                                
                                            case 'S' or 's':
                                                
                                                // Match a character in the set [Uu].
                                                if ((uint)slice.Length < 5 || ((slice[4] | 0x20) != 'u'))
                                                {
                                                    goto AlternationBranch1;
                                                }
                                                
                                                pos += 5;
                                                slice = inputSpan.Slice(pos);
                                                break;
                                                
                                            default:
                                                goto AlternationBranch1;
                                        }
                                    //}
                                    
                                    alternation_branch1 = 10;
                                    goto AlternationMatch1;
                                //}
                                
                                AlternationBacktrack1:
                                base.CheckTimeout();
                                
                                switch (alternation_branch1)
                                {
                                    case 0:
                                        goto AlternationBranch2;
                                    case 1:
                                        goto AlternationBranch3;
                                    case 2:
                                        goto AlternationBranch4;
                                    case 3:
                                        goto AlternationBranch5;
                                    case 4:
                                        goto AlternationBranch6;
                                    case 5:
                                        goto AlternationBranch7;
                                    case 6:
                                        goto AlternationBranch8;
                                    case 7:
                                        goto AlternationBranch9;
                                    case 8:
                                        goto AlternationBranch10;
                                    case 9:
                                        goto AlternationBranch11;
                                    case 10:
                                        goto AlternationBranch1;
                                }
                                
                                AlternationMatch1:;
                            //}
                            
                            alternation_branch = 1;
                            goto AlternationMatch;
                            
                            AlternationBranch1:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 2
                        //{
                            if ((uint)slice.Length < 4 ||
                                !slice.StartsWith("sgn-", StringComparison.OrdinalIgnoreCase)) // Match the string "sgn-" (ordinal case-insensitive)
                            {
                                goto AlternationBranch12;
                            }
                            
                            // Match with 2 alternative expressions.
                            //{
                                alternation_starting_pos2 = pos;
                                
                                // Branch 0
                                //{
                                    if ((uint)slice.Length < 7 ||
                                        !slice.Slice(4).StartsWith("be-", StringComparison.OrdinalIgnoreCase)) // Match the string "be-" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch13;
                                    }
                                    
                                    // Match with 2 alternative expressions.
                                    //{
                                        if ((uint)slice.Length < 8)
                                        {
                                            goto AlternationBranch13;
                                        }
                                        
                                        switch (slice[7])
                                        {
                                            case 'F' or 'f':
                                                
                                                // Match a character in the set [Rr].
                                                if ((uint)slice.Length < 9 || ((slice[8] | 0x20) != 'r'))
                                                {
                                                    goto AlternationBranch13;
                                                }
                                                
                                                pos += 9;
                                                slice = inputSpan.Slice(pos);
                                                break;
                                                
                                            case 'N' or 'n':
                                                
                                                // Match a character in the set [Ll].
                                                if ((uint)slice.Length < 9 || ((slice[8] | 0x20) != 'l'))
                                                {
                                                    goto AlternationBranch13;
                                                }
                                                
                                                pos += 9;
                                                slice = inputSpan.Slice(pos);
                                                break;
                                                
                                            default:
                                                goto AlternationBranch13;
                                        }
                                    //}
                                    
                                    alternation_branch2 = 0;
                                    goto AlternationMatch2;
                                    
                                    AlternationBranch13:
                                    pos = alternation_starting_pos2;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 1
                                //{
                                    if ((uint)slice.Length < 9 ||
                                        !slice.Slice(4).StartsWith("ch-de", StringComparison.OrdinalIgnoreCase)) // Match the string "ch-de" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch12;
                                    }
                                    
                                    alternation_branch2 = 1;
                                    pos += 9;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch2;
                                //}
                                
                                AlternationBacktrack2:
                                base.CheckTimeout();
                                
                                switch (alternation_branch2)
                                {
                                    case 0:
                                        goto AlternationBranch13;
                                    case 1:
                                        goto AlternationBranch12;
                                }
                                
                                AlternationMatch2:;
                            //}
                            
                            alternation_branch = 2;
                            goto AlternationMatch;
                            
                            AlternationBranch12:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 3
                        //{
                            if ((uint)slice.Length < 10 ||
                                !slice.StartsWith("art-lojban", StringComparison.OrdinalIgnoreCase)) // Match the string "art-lojban" (ordinal case-insensitive)
                            {
                                goto AlternationBranch14;
                            }
                            
                            alternation_branch = 3;
                            pos += 10;
                            slice = inputSpan.Slice(pos);
                            goto AlternationMatch;
                            
                            AlternationBranch14:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 4
                        //{
                            if ((uint)slice.Length < 11 ||
                                !slice.StartsWith("cel-gaulish", StringComparison.OrdinalIgnoreCase)) // Match the string "cel-gaulish" (ordinal case-insensitive)
                            {
                                goto AlternationBranch15;
                            }
                            
                            alternation_branch = 4;
                            pos += 11;
                            slice = inputSpan.Slice(pos);
                            goto AlternationMatch;
                            
                            AlternationBranch15:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 5
                        //{
                            if ((uint)slice.Length < 3 ||
                                !slice.StartsWith("no-", StringComparison.OrdinalIgnoreCase)) // Match the string "no-" (ordinal case-insensitive)
                            {
                                goto AlternationBranch16;
                            }
                            
                            // Match with 2 alternative expressions.
                            //{
                                if ((uint)slice.Length < 4)
                                {
                                    goto AlternationBranch16;
                                }
                                
                                switch (slice[3])
                                {
                                    case 'B' or 'b':
                                        
                                        if ((uint)slice.Length < 6 ||
                                            ((slice[4] | 0x20) != 'o') || // Match a character in the set [Oo].
                                            ((((ch = slice[5]) | 0x20) != 'k') & (ch != 'K'))) // Match a character in the set [Kk\u212A].
                                        {
                                            goto AlternationBranch16;
                                        }
                                        
                                        pos += 6;
                                        slice = inputSpan.Slice(pos);
                                        break;
                                        
                                    case 'N' or 'n':
                                        
                                        if ((uint)slice.Length < 6 ||
                                            !slice.Slice(4).StartsWith("yn", StringComparison.OrdinalIgnoreCase)) // Match the string "yn" (ordinal case-insensitive)
                                        {
                                            goto AlternationBranch16;
                                        }
                                        
                                        pos += 6;
                                        slice = inputSpan.Slice(pos);
                                        break;
                                        
                                    default:
                                        goto AlternationBranch16;
                                }
                            //}
                            
                            alternation_branch = 5;
                            goto AlternationMatch;
                            
                            AlternationBranch16:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 6
                        //{
                            if ((uint)slice.Length < 3 ||
                                !slice.StartsWith("zh-", StringComparison.OrdinalIgnoreCase)) // Match the string "zh-" (ordinal case-insensitive)
                            {
                                goto AlternationBranch17;
                            }
                            
                            // Match with 4 alternative expressions.
                            //{
                                alternation_starting_pos3 = pos;
                                
                                // Branch 0
                                //{
                                    if ((uint)slice.Length < 8 ||
                                        !slice.Slice(3).StartsWith("guoyu", StringComparison.OrdinalIgnoreCase)) // Match the string "guoyu" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch18;
                                    }
                                    
                                    alternation_branch3 = 0;
                                    pos += 8;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch3;
                                    
                                    AlternationBranch18:
                                    pos = alternation_starting_pos3;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 1
                                //{
                                    if ((uint)slice.Length < 8 ||
                                        !slice.Slice(3).StartsWith("ha", StringComparison.OrdinalIgnoreCase) || // Match the string "ha" (ordinal case-insensitive)
                                        ((((ch = slice[5]) | 0x20) != 'k') & (ch != 'K')) || // Match a character in the set [Kk\u212A] exactly 2 times.
                                        ((((ch = slice[6]) | 0x20) != 'k') & (ch != 'K')) ||
                                        ((slice[7] | 0x20) != 'a')) // Match a character in the set [Aa].
                                    {
                                        goto AlternationBranch19;
                                    }
                                    
                                    alternation_branch3 = 1;
                                    pos += 8;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch3;
                                    
                                    AlternationBranch19:
                                    pos = alternation_starting_pos3;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 2
                                //{
                                    if ((uint)slice.Length < 5 ||
                                        !slice.Slice(3).StartsWith("mi", StringComparison.OrdinalIgnoreCase)) // Match the string "mi" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch20;
                                    }
                                    
                                    // Match with 2 alternative expressions.
                                    //{
                                        alternation_starting_pos4 = pos;
                                        
                                        // Branch 0
                                        //{
                                            // Match a character in the set [Nn].
                                            if ((uint)slice.Length < 6 || ((slice[5] | 0x20) != 'n'))
                                            {
                                                goto AlternationBranch21;
                                            }
                                            
                                            alternation_branch4 = 0;
                                            pos += 6;
                                            slice = inputSpan.Slice(pos);
                                            goto AlternationMatch4;
                                            
                                            AlternationBranch21:
                                            pos = alternation_starting_pos4;
                                            slice = inputSpan.Slice(pos);
                                        //}
                                        
                                        // Branch 1
                                        //{
                                            if ((uint)slice.Length < 10 ||
                                                !slice.Slice(5).StartsWith("n-nan", StringComparison.OrdinalIgnoreCase)) // Match the string "n-nan" (ordinal case-insensitive)
                                            {
                                                goto AlternationBranch20;
                                            }
                                            
                                            alternation_branch4 = 1;
                                            pos += 10;
                                            slice = inputSpan.Slice(pos);
                                            goto AlternationMatch4;
                                        //}
                                        
                                        AlternationBacktrack4:
                                        base.CheckTimeout();
                                        
                                        switch (alternation_branch4)
                                        {
                                            case 0:
                                                goto AlternationBranch21;
                                            case 1:
                                                goto AlternationBranch20;
                                        }
                                        
                                        AlternationMatch4:;
                                    //}
                                    
                                    alternation_branch3 = 2;
                                    goto AlternationMatch3;
                                    
                                    AlternationBranch20:
                                    pos = alternation_starting_pos3;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 3
                                //{
                                    if ((uint)slice.Length < 8 ||
                                        !slice.Slice(3).StartsWith("xiang", StringComparison.OrdinalIgnoreCase)) // Match the string "xiang" (ordinal case-insensitive)
                                    {
                                        goto AlternationBranch17;
                                    }
                                    
                                    alternation_branch3 = 3;
                                    pos += 8;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch3;
                                //}
                                
                                AlternationBacktrack3:
                                base.CheckTimeout();
                                
                                switch (alternation_branch3)
                                {
                                    case 0:
                                        goto AlternationBranch18;
                                    case 1:
                                        goto AlternationBranch19;
                                    case 2:
                                        goto AlternationBacktrack4;
                                    case 3:
                                        goto AlternationBranch17;
                                }
                                
                                AlternationMatch3:;
                            //}
                            
                            alternation_branch = 6;
                            goto AlternationMatch;
                            
                            AlternationBranch17:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 7
                        //{
                            // Match with 3 alternative expressions.
                            //{
                                alternation_starting_pos5 = pos;
                                
                                // Branch 0
                                //{
                                    // Match a character in the set [A-Za-z\u212A] greedily at least 2 and at most 3 times.
                                    //{
                                        charloop_starting_pos = pos;
                                        
                                        int iteration = 0;
                                        while (iteration < 3 && (uint)iteration < (uint)slice.Length && ((ch = slice[iteration]) < 128 ? char.IsAsciiLetter(ch) : RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                        {
                                            iteration++;
                                        }
                                        
                                        if (iteration < 2)
                                        {
                                            goto AlternationBranch23;
                                        }
                                        
                                        slice = slice.Slice(iteration);
                                        pos += iteration;
                                        
                                        charloop_ending_pos = pos;
                                        charloop_starting_pos += 2;
                                        goto CharLoopEnd;
                                        
                                        CharLoopBacktrack:
                                        
                                        base.CheckTimeout();
                                        
                                        if (charloop_starting_pos >= charloop_ending_pos)
                                        {
                                            goto AlternationBranch23;
                                        }
                                        pos = --charloop_ending_pos;
                                        slice = inputSpan.Slice(pos);
                                        
                                        CharLoopEnd:
                                    //}
                                    
                                    // Optional (greedy).
                                    //{
                                        loop_iteration = 0;
                                        
                                        LoopBody:
                                        Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                        
                                        loop_iteration++;
                                        
                                        if ((uint)slice.Length < 4 ||
                                            slice[0] != '-' || // Match '-'.
                                            ((ch = slice[1]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) || // Match a character in the set [A-Za-z\u212A] exactly 3 times.
                                            ((ch = slice[2]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                            ((ch = slice[3]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                        {
                                            goto LoopIterationNoMatch;
                                        }
                                        
                                        // Loop greedily at most 2 times.
                                        //{
                                            pos += 4;
                                            slice = inputSpan.Slice(pos);
                                            loop_iteration1 = 0;
                                            
                                            LoopBody1:
                                            Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                            
                                            loop_iteration1++;
                                            
                                            if ((uint)slice.Length < 4 ||
                                                slice[0] != '-' || // Match '-'.
                                                ((ch = slice[1]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) || // Match a character in the set [A-Za-z\u212A] exactly 3 times.
                                                ((ch = slice[2]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                                ((ch = slice[3]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                            {
                                                goto LoopIterationNoMatch1;
                                            }
                                            
                                            pos += 4;
                                            slice = inputSpan.Slice(pos);
                                            
                                            // The loop has an upper bound of 2. Continue iterating greedily if it hasn't yet been reached.
                                            if (loop_iteration1 < 2)
                                            {
                                                goto LoopBody1;
                                            }
                                            goto LoopEnd1;
                                            
                                            // The loop iteration failed. Put state back to the way it was before the iteration.
                                            LoopIterationNoMatch1:
                                            if (--loop_iteration1 < 0)
                                            {
                                                // Unable to match the remainder of the expression after exhausting the loop.
                                                goto LoopIterationNoMatch;
                                            }
                                            pos = base.runstack![--stackpos];
                                            slice = inputSpan.Slice(pos);
                                            LoopEnd1:
                                            
                                            Utilities.StackPush(ref base.runstack!, ref stackpos, loop_iteration1);
                                            goto LoopSkipBacktrack;
                                            
                                            LoopBacktrack:
                                            loop_iteration1 = base.runstack![--stackpos];
                                            base.CheckTimeout();
                                            
                                            goto LoopIterationNoMatch1;
                                            
                                            LoopSkipBacktrack:;
                                        //}
                                        
                                        
                                        // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                                        if (loop_iteration == 0)
                                        {
                                            goto LoopBody;
                                        }
                                        goto LoopEnd;
                                        
                                        // The loop iteration failed. Put state back to the way it was before the iteration.
                                        LoopIterationNoMatch:
                                        if (--loop_iteration < 0)
                                        {
                                            // Unable to match the remainder of the expression after exhausting the loop.
                                            goto CharLoopBacktrack;
                                        }
                                        pos = base.runstack![--stackpos];
                                        slice = inputSpan.Slice(pos);
                                        goto LoopEnd;
                                        
                                        LoopBacktrack1:
                                        base.CheckTimeout();
                                        
                                        if (loop_iteration == 0)
                                        {
                                            // No iterations of the loop remain to backtrack into. Fail the loop.
                                            goto CharLoopBacktrack;
                                        }
                                        goto LoopBacktrack;
                                        LoopEnd:;
                                    //}
                                    
                                    alternation_branch5 = 0;
                                    goto AlternationMatch5;
                                    
                                    AlternationBranch23:
                                    pos = alternation_starting_pos5;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 1
                                //{
                                    // Match a character in the set [A-Za-z\u212A] exactly 4 times.
                                    {
                                        if ((uint)slice.Length < 4 ||
                                            ((ch = slice[0]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                            ((ch = slice[1]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                            ((ch = slice[2]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                            ((ch = slice[3]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                        {
                                            goto AlternationBranch24;
                                        }
                                    }
                                    
                                    alternation_branch5 = 1;
                                    pos += 4;
                                    slice = inputSpan.Slice(pos);
                                    goto AlternationMatch5;
                                    
                                    AlternationBranch24:
                                    pos = alternation_starting_pos5;
                                    slice = inputSpan.Slice(pos);
                                //}
                                
                                // Branch 2
                                //{
                                    // Match a character in the set [A-Za-z\u212A] greedily at least 5 and at most 8 times.
                                    //{
                                        charloop_starting_pos1 = pos;
                                        
                                        int iteration1 = 0;
                                        while (iteration1 < 8 && (uint)iteration1 < (uint)slice.Length && ((ch = slice[iteration1]) < 128 ? char.IsAsciiLetter(ch) : RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                        {
                                            iteration1++;
                                        }
                                        
                                        if (iteration1 < 5)
                                        {
                                            goto AlternationBranch22;
                                        }
                                        
                                        slice = slice.Slice(iteration1);
                                        pos += iteration1;
                                        
                                        charloop_ending_pos1 = pos;
                                        charloop_starting_pos1 += 5;
                                        goto CharLoopEnd1;
                                        
                                        CharLoopBacktrack1:
                                        
                                        base.CheckTimeout();
                                        
                                        if (charloop_starting_pos1 >= charloop_ending_pos1)
                                        {
                                            goto AlternationBranch22;
                                        }
                                        pos = --charloop_ending_pos1;
                                        slice = inputSpan.Slice(pos);
                                        
                                        CharLoopEnd1:
                                    //}
                                    
                                    alternation_branch5 = 2;
                                    goto AlternationMatch5;
                                //}
                                
                                AlternationBacktrack5:
                                base.CheckTimeout();
                                
                                switch (alternation_branch5)
                                {
                                    case 0:
                                        goto LoopBacktrack1;
                                    case 1:
                                        goto AlternationBranch24;
                                    case 2:
                                        goto CharLoopBacktrack1;
                                }
                                
                                AlternationMatch5:;
                            //}
                            
                            // Optional (greedy).
                            //{
                                loop_iteration2 = 0;
                                
                                LoopBody2:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                
                                loop_iteration2++;
                                
                                if ((uint)slice.Length < 5 ||
                                    slice[0] != '-' || // Match '-'.
                                    ((ch = slice[1]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) || // Match a character in the set [A-Za-z\u212A] exactly 4 times.
                                    ((ch = slice[2]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                    ((ch = slice[3]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                    ((ch = slice[4]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                {
                                    goto LoopIterationNoMatch2;
                                }
                                
                                pos += 5;
                                slice = inputSpan.Slice(pos);
                                
                                // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                                if (loop_iteration2 == 0)
                                {
                                    goto LoopBody2;
                                }
                                goto LoopEnd2;
                                
                                // The loop iteration failed. Put state back to the way it was before the iteration.
                                LoopIterationNoMatch2:
                                if (--loop_iteration2 < 0)
                                {
                                    // Unable to match the remainder of the expression after exhausting the loop.
                                    goto AlternationBacktrack5;
                                }
                                pos = base.runstack![--stackpos];
                                slice = inputSpan.Slice(pos);
                                LoopEnd2:;
                            //}
                            
                            // Optional (greedy).
                            //{
                                loop_iteration3 = 0;
                                
                                LoopBody3:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                
                                loop_iteration3++;
                                
                                // Match '-'.
                                if (slice.IsEmpty || slice[0] != '-')
                                {
                                    goto LoopIterationNoMatch3;
                                }
                                
                                // Match with 2 alternative expressions.
                                //{
                                    if ((uint)slice.Length < 2)
                                    {
                                        goto LoopIterationNoMatch3;
                                    }
                                    
                                    switch (slice[1])
                                    {
                                        case 'A' or 'B' or 'C' or 'D' or 'E' or 'F' or 'G' or 'H' or 'I' or 'J' or 'K' or 'L' or 'M' or 'N' or 'O' or 'P' or 'Q' or 'R' or 'S' or 'T' or 'U' or 'V' or 'W' or 'X' or 'Y' or 'Z' or 'a' or 'b' or 'c' or 'd' or 'e' or 'f' or 'g' or 'h' or 'i' or 'j' or 'k' or 'l' or 'm' or 'n' or 'o' or 'p' or 'q' or 'r' or 's' or 't' or 'u' or 'v' or 'w' or 'x' or 'y' or 'z' or 'K':
                                            // Match a character in the set [A-Za-z\u212A] exactly 2 times.
                                            {
                                                if ((uint)slice.Length < 3 ||
                                                    ((ch = slice[1]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")) ||
                                                    ((ch = slice[2]) < 128 ? !char.IsAsciiLetter(ch) : !RegexRunner.CharInClass((char)ch, "\0\u0006\0A[a{KÅ")))
                                                {
                                                    goto LoopIterationNoMatch3;
                                                }
                                            }
                                            
                                            pos += 3;
                                            slice = inputSpan.Slice(pos);
                                            break;
                                            
                                        case '0' or '1' or '2' or '3' or '4' or '5' or '6' or '7' or '8' or '9':
                                            // Match a character in the set [0-9] exactly 3 times.
                                            {
                                                if ((uint)slice.Length < 4 ||
                                                    !char.IsAsciiDigit(slice[1]) ||
                                                    !char.IsAsciiDigit(slice[2]) ||
                                                    !char.IsAsciiDigit(slice[3]))
                                                {
                                                    goto LoopIterationNoMatch3;
                                                }
                                            }
                                            
                                            pos += 4;
                                            slice = inputSpan.Slice(pos);
                                            break;
                                            
                                        default:
                                            goto LoopIterationNoMatch3;
                                    }
                                //}
                                
                                
                                // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                                if (loop_iteration3 == 0)
                                {
                                    goto LoopBody3;
                                }
                                goto LoopEnd3;
                                
                                // The loop iteration failed. Put state back to the way it was before the iteration.
                                LoopIterationNoMatch3:
                                if (--loop_iteration3 < 0)
                                {
                                    // Unable to match the remainder of the expression after exhausting the loop.
                                    goto LoopIterationNoMatch2;
                                }
                                pos = base.runstack![--stackpos];
                                slice = inputSpan.Slice(pos);
                                LoopEnd3:;
                            //}
                            
                            // Loop greedily any number of times.
                            //{
                                loop_iteration4 = 0;
                                
                                LoopBody4:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                
                                loop_iteration4++;
                                
                                // Match '-'.
                                if (slice.IsEmpty || slice[0] != '-')
                                {
                                    goto LoopIterationNoMatch4;
                                }
                                
                                // Match with 2 alternative expressions.
                                //{
                                    int alternation_starting_pos6 = pos;
                                    
                                    // Branch 0
                                    //{
                                        // Match a character in the set [0-9A-Za-z\u212A] greedily at least 5 and at most 8 times.
                                        //{
                                            pos++;
                                            slice = inputSpan.Slice(pos);
                                            charloop_starting_pos2 = pos;
                                            
                                            int iteration2 = 0;
                                            while (iteration2 < 8 && (uint)iteration2 < (uint)slice.Length && ((ch = slice[iteration2]) < 128 ? char.IsAsciiLetterOrDigit(ch) : RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")))
                                            {
                                                iteration2++;
                                            }
                                            
                                            if (iteration2 < 5)
                                            {
                                                goto AlternationBranch25;
                                            }
                                            
                                            slice = slice.Slice(iteration2);
                                            pos += iteration2;
                                            
                                            charloop_ending_pos2 = pos;
                                            charloop_starting_pos2 += 5;
                                            goto CharLoopEnd2;
                                            
                                            CharLoopBacktrack2:
                                            Utilities.StackPop(base.runstack!, ref stackpos, out charloop_ending_pos2, out charloop_starting_pos2);
                                            
                                            base.CheckTimeout();
                                            
                                            if (charloop_starting_pos2 >= charloop_ending_pos2)
                                            {
                                                goto AlternationBranch25;
                                            }
                                            pos = --charloop_ending_pos2;
                                            slice = inputSpan.Slice(pos);
                                            
                                            CharLoopEnd2:
                                            Utilities.StackPush(ref base.runstack!, ref stackpos, charloop_starting_pos2, charloop_ending_pos2);
                                        //}
                                        
                                        Utilities.StackPush(ref base.runstack!, ref stackpos, 0, alternation_starting_pos6);
                                        goto AlternationMatch6;
                                        
                                        AlternationBranch25:
                                        pos = alternation_starting_pos6;
                                        slice = inputSpan.Slice(pos);
                                    //}
                                    
                                    // Branch 1
                                    //{
                                        if ((uint)slice.Length < 5 ||
                                            !char.IsAsciiDigit(slice[1]) || // Match a character in the set [0-9].
                                            ((ch = slice[2]) < 128 ? !char.IsAsciiLetterOrDigit(ch) : !RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")) || // Match a character in the set [0-9A-Za-z\u212A] exactly 3 times.
                                            ((ch = slice[3]) < 128 ? !char.IsAsciiLetterOrDigit(ch) : !RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")) ||
                                            ((ch = slice[4]) < 128 ? !char.IsAsciiLetterOrDigit(ch) : !RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")))
                                        {
                                            goto LoopIterationNoMatch4;
                                        }
                                        
                                        Utilities.StackPush(ref base.runstack!, ref stackpos, 1, alternation_starting_pos6);
                                        pos += 5;
                                        slice = inputSpan.Slice(pos);
                                        goto AlternationMatch6;
                                    //}
                                    
                                    AlternationBacktrack6:
                                    base.CheckTimeout();
                                    
                                    alternation_starting_pos6 = base.runstack![--stackpos];
                                    switch (base.runstack![--stackpos])
                                    {
                                        case 0:
                                            goto CharLoopBacktrack2;
                                        case 1:
                                            goto LoopIterationNoMatch4;
                                    }
                                    
                                    AlternationMatch6:;
                                //}
                                
                                
                                // The loop has no upper bound. Continue iterating greedily.
                                goto LoopBody4;
                                
                                // The loop iteration failed. Put state back to the way it was before the iteration.
                                LoopIterationNoMatch4:
                                if (--loop_iteration4 < 0)
                                {
                                    // Unable to match the remainder of the expression after exhausting the loop.
                                    goto LoopIterationNoMatch3;
                                }
                                pos = base.runstack![--stackpos];
                                slice = inputSpan.Slice(pos);
                                goto LoopEnd4;
                                
                                LoopBacktrack2:
                                base.CheckTimeout();
                                
                                if (loop_iteration4 == 0)
                                {
                                    // No iterations of the loop remain to backtrack into. Fail the loop.
                                    goto LoopIterationNoMatch3;
                                }
                                goto AlternationBacktrack6;
                                LoopEnd4:;
                            //}
                            
                            // Loop greedily any number of times.
                            //{
                                loop_iteration5 = 0;
                                
                                LoopBody5:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                
                                loop_iteration5++;
                                
                                if ((uint)slice.Length < 2 ||
                                    slice[0] != '-' || // Match '-'.
                                    ((ch = slice[1]) < 128 ? ("\0\0\0Ͽ\ufffeۿ\ufffeۿ"[ch >> 4] & (1 << (ch & 0xF))) == 0 : !RegexRunner.CharInClass((char)ch, "\0\f\00:AXY[axy{KÅ"))) // Match a character in the set [0-9A-WYZa-wyz\u212A].
                                {
                                    goto LoopIterationNoMatch5;
                                }
                                
                                // Loop greedily at least once.
                                //{
                                    pos += 2;
                                    slice = inputSpan.Slice(pos);
                                    loop_iteration6 = 0;
                                    
                                    LoopBody6:
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                    
                                    loop_iteration6++;
                                    
                                    // Match '-'.
                                    if (slice.IsEmpty || slice[0] != '-')
                                    {
                                        goto LoopIterationNoMatch6;
                                    }
                                    
                                    // Match a character in the set [0-9A-Za-z\u212A] greedily at least 2 and at most 8 times.
                                    //{
                                        pos++;
                                        slice = inputSpan.Slice(pos);
                                        charloop_starting_pos3 = pos;
                                        
                                        int iteration3 = 0;
                                        while (iteration3 < 8 && (uint)iteration3 < (uint)slice.Length && ((ch = slice[iteration3]) < 128 ? char.IsAsciiLetterOrDigit(ch) : RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")))
                                        {
                                            iteration3++;
                                        }
                                        
                                        if (iteration3 < 2)
                                        {
                                            goto LoopIterationNoMatch6;
                                        }
                                        
                                        slice = slice.Slice(iteration3);
                                        pos += iteration3;
                                        
                                        charloop_ending_pos3 = pos;
                                        charloop_starting_pos3 += 2;
                                        goto CharLoopEnd3;
                                        
                                        CharLoopBacktrack3:
                                        Utilities.StackPop(base.runstack!, ref stackpos, out charloop_ending_pos3, out charloop_starting_pos3);
                                        
                                        base.CheckTimeout();
                                        
                                        if (charloop_starting_pos3 >= charloop_ending_pos3)
                                        {
                                            goto LoopIterationNoMatch6;
                                        }
                                        pos = --charloop_ending_pos3;
                                        slice = inputSpan.Slice(pos);
                                        
                                        CharLoopEnd3:
                                        Utilities.StackPush(ref base.runstack!, ref stackpos, charloop_starting_pos3, charloop_ending_pos3);
                                    //}
                                    
                                    
                                    // The loop has no upper bound. Continue iterating greedily.
                                    goto LoopBody6;
                                    
                                    // The loop iteration failed. Put state back to the way it was before the iteration.
                                    LoopIterationNoMatch6:
                                    if (--loop_iteration6 < 0)
                                    {
                                        // Unable to match the remainder of the expression after exhausting the loop.
                                        goto LoopIterationNoMatch5;
                                    }
                                    pos = base.runstack![--stackpos];
                                    slice = inputSpan.Slice(pos);
                                    if (loop_iteration6 == 0)
                                    {
                                        // No iterations have been matched to backtrack into. Fail the loop.
                                        goto LoopIterationNoMatch5;
                                    }
                                    
                                    goto LoopEnd6;
                                    
                                    LoopBacktrack3:
                                    base.CheckTimeout();
                                    
                                    if (loop_iteration6 == 0)
                                    {
                                        // No iterations of the loop remain to backtrack into. Fail the loop.
                                        goto LoopIterationNoMatch5;
                                    }
                                    goto CharLoopBacktrack3;
                                    LoopEnd6:
                                    
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, loop_iteration6);
                                    goto LoopSkipBacktrack1;
                                    
                                    LoopBacktrack4:
                                    loop_iteration6 = base.runstack![--stackpos];
                                    base.CheckTimeout();
                                    
                                    goto LoopBacktrack3;
                                    
                                    LoopSkipBacktrack1:;
                                //}
                                
                                
                                // The loop has no upper bound. Continue iterating greedily.
                                goto LoopBody5;
                                
                                // The loop iteration failed. Put state back to the way it was before the iteration.
                                LoopIterationNoMatch5:
                                if (--loop_iteration5 < 0)
                                {
                                    // Unable to match the remainder of the expression after exhausting the loop.
                                    goto LoopBacktrack2;
                                }
                                pos = base.runstack![--stackpos];
                                slice = inputSpan.Slice(pos);
                                goto LoopEnd5;
                                
                                LoopBacktrack5:
                                base.CheckTimeout();
                                
                                if (loop_iteration5 == 0)
                                {
                                    // No iterations of the loop remain to backtrack into. Fail the loop.
                                    goto LoopBacktrack2;
                                }
                                goto LoopBacktrack4;
                                LoopEnd5:;
                            //}
                            
                            // Optional (greedy).
                            //{
                                loop_iteration7 = 0;
                                
                                LoopBody7:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                
                                loop_iteration7++;
                                
                                if ((uint)slice.Length < 2 ||
                                    !slice.StartsWith("-x", StringComparison.OrdinalIgnoreCase)) // Match the string "-x" (ordinal case-insensitive)
                                {
                                    goto LoopIterationNoMatch7;
                                }
                                
                                // Loop greedily at least once.
                                //{
                                    pos += 2;
                                    slice = inputSpan.Slice(pos);
                                    loop_iteration8 = 0;
                                    
                                    LoopBody8:
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                    
                                    loop_iteration8++;
                                    
                                    // Match '-'.
                                    if (slice.IsEmpty || slice[0] != '-')
                                    {
                                        goto LoopIterationNoMatch8;
                                    }
                                    
                                    // Match a character in the set [0-9A-Za-z\u212A] greedily at least 1 and at most 8 times.
                                    //{
                                        pos++;
                                        slice = inputSpan.Slice(pos);
                                        charloop_starting_pos4 = pos;
                                        
                                        int iteration4 = 0;
                                        while (iteration4 < 8 && (uint)iteration4 < (uint)slice.Length && ((ch = slice[iteration4]) < 128 ? char.IsAsciiLetterOrDigit(ch) : RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")))
                                        {
                                            iteration4++;
                                        }
                                        
                                        if (iteration4 == 0)
                                        {
                                            goto LoopIterationNoMatch8;
                                        }
                                        
                                        slice = slice.Slice(iteration4);
                                        pos += iteration4;
                                        
                                        charloop_ending_pos4 = pos;
                                        charloop_starting_pos4++;
                                        goto CharLoopEnd4;
                                        
                                        CharLoopBacktrack4:
                                        Utilities.StackPop(base.runstack!, ref stackpos, out charloop_ending_pos4, out charloop_starting_pos4);
                                        
                                        base.CheckTimeout();
                                        
                                        if (charloop_starting_pos4 >= charloop_ending_pos4)
                                        {
                                            goto LoopIterationNoMatch8;
                                        }
                                        pos = --charloop_ending_pos4;
                                        slice = inputSpan.Slice(pos);
                                        
                                        CharLoopEnd4:
                                        Utilities.StackPush(ref base.runstack!, ref stackpos, charloop_starting_pos4, charloop_ending_pos4);
                                    //}
                                    
                                    
                                    // The loop has no upper bound. Continue iterating greedily.
                                    goto LoopBody8;
                                    
                                    // The loop iteration failed. Put state back to the way it was before the iteration.
                                    LoopIterationNoMatch8:
                                    if (--loop_iteration8 < 0)
                                    {
                                        // Unable to match the remainder of the expression after exhausting the loop.
                                        goto LoopIterationNoMatch7;
                                    }
                                    pos = base.runstack![--stackpos];
                                    slice = inputSpan.Slice(pos);
                                    if (loop_iteration8 == 0)
                                    {
                                        // No iterations have been matched to backtrack into. Fail the loop.
                                        goto LoopIterationNoMatch7;
                                    }
                                    
                                    goto LoopEnd8;
                                    
                                    LoopBacktrack6:
                                    base.CheckTimeout();
                                    
                                    if (loop_iteration8 == 0)
                                    {
                                        // No iterations of the loop remain to backtrack into. Fail the loop.
                                        goto LoopIterationNoMatch7;
                                    }
                                    goto CharLoopBacktrack4;
                                    LoopEnd8:
                                    
                                    Utilities.StackPush(ref base.runstack!, ref stackpos, loop_iteration8);
                                    goto LoopSkipBacktrack2;
                                    
                                    LoopBacktrack7:
                                    loop_iteration8 = base.runstack![--stackpos];
                                    base.CheckTimeout();
                                    
                                    goto LoopBacktrack6;
                                    
                                    LoopSkipBacktrack2:;
                                //}
                                
                                
                                // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                                if (loop_iteration7 == 0)
                                {
                                    goto LoopBody7;
                                }
                                goto LoopEnd7;
                                
                                // The loop iteration failed. Put state back to the way it was before the iteration.
                                LoopIterationNoMatch7:
                                if (--loop_iteration7 < 0)
                                {
                                    // Unable to match the remainder of the expression after exhausting the loop.
                                    goto LoopBacktrack5;
                                }
                                pos = base.runstack![--stackpos];
                                slice = inputSpan.Slice(pos);
                                goto LoopEnd7;
                                
                                LoopBacktrack8:
                                base.CheckTimeout();
                                
                                if (loop_iteration7 == 0)
                                {
                                    // No iterations of the loop remain to backtrack into. Fail the loop.
                                    goto LoopBacktrack5;
                                }
                                goto LoopBacktrack7;
                                LoopEnd7:;
                            //}
                            
                            alternation_branch = 7;
                            goto AlternationMatch;
                            
                            AlternationBranch22:
                            pos = alternation_starting_pos;
                            slice = inputSpan.Slice(pos);
                        //}
                        
                        // Branch 8
                        //{
                            // Match a character in the set [Xx].
                            if (slice.IsEmpty || ((slice[0] | 0x20) != 'x'))
                            {
                                return false; // The input didn't match.
                            }
                            
                            // Loop greedily at least once.
                            //{
                                pos++;
                                slice = inputSpan.Slice(pos);
                                loop_iteration9 = 0;
                                
                                LoopBody9:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, pos);
                                
                                loop_iteration9++;
                                
                                // Match '-'.
                                if (slice.IsEmpty || slice[0] != '-')
                                {
                                    goto LoopIterationNoMatch9;
                                }
                                
                                // Match a character in the set [0-9A-Za-z\u212A] atomically at least 1 and at most 8 times.
                                {
                                    pos++;
                                    slice = inputSpan.Slice(pos);
                                    int iteration5 = 0;
                                    while (iteration5 < 8 && (uint)iteration5 < (uint)slice.Length && ((ch = slice[iteration5]) < 128 ? char.IsAsciiLetterOrDigit(ch) : RegexRunner.CharInClass((char)ch, "\0\b\00:A[a{KÅ")))
                                    {
                                        iteration5++;
                                    }
                                    
                                    if (iteration5 == 0)
                                    {
                                        goto LoopIterationNoMatch9;
                                    }
                                    
                                    slice = slice.Slice(iteration5);
                                    pos += iteration5;
                                }
                                
                                
                                // The loop has no upper bound. Continue iterating greedily.
                                goto LoopBody9;
                                
                                // The loop iteration failed. Put state back to the way it was before the iteration.
                                LoopIterationNoMatch9:
                                if (--loop_iteration9 < 0)
                                {
                                    // Unable to match the remainder of the expression after exhausting the loop.
                                    return false; // The input didn't match.
                                }
                                pos = base.runstack![--stackpos];
                                slice = inputSpan.Slice(pos);
                                if (loop_iteration9 == 0)
                                {
                                    // All possible iterations have matched, but it's below the required minimum of 1. Fail the loop.
                                    return false; // The input didn't match.
                                }
                                
                                LoopEnd9:;
                            //}
                            
                            alternation_branch = 8;
                            goto AlternationMatch;
                        //}
                        
                        AlternationBacktrack:
                        base.CheckTimeout();
                        
                        switch (alternation_branch)
                        {
                            case 0:
                                goto AlternationBranch;
                            case 1:
                                goto AlternationBacktrack1;
                            case 2:
                                goto AlternationBacktrack2;
                            case 3:
                                goto AlternationBranch14;
                            case 4:
                                goto AlternationBranch15;
                            case 5:
                                goto AlternationBranch16;
                            case 6:
                                goto AlternationBacktrack3;
                            case 7:
                                goto LoopBacktrack8;
                            case 8:
                                goto LoopIterationNoMatch9;
                        }
                        
                        AlternationMatch:;
                    //}
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (pos < inputSpan.Length - 1 || ((uint)pos < (uint)inputSpan.Length && inputSpan[pos] != '\n'))
                    {
                        goto AlternationBacktrack;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.12.21509")]
    file static class Utilities
    {
        /// <summary>Pops 2 values from the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPop(int[] stack, ref int pos, out int arg0, out int arg1)
        {
            arg0 = stack[--pos];
            arg1 = stack[--pos];
        }
        
        /// <summary>Pushes 1 value onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0)
        {
            // If there's space available for the value, store it.
            int[] s = stack;
            int p = pos;
            if ((uint)p < (uint)s.Length)
            {
                s[p] = arg0;
                pos++;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0);
        
            // <summary>Resize the backtracking stack array and push 1 value onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0)
            {
                Array.Resize(ref stack, (pos + 0) * 2);
                StackPush(ref stack, ref pos, arg0);
            }
        }
        
        /// <summary>Pushes 2 values onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0, int arg1)
        {
            // If there's space available for all 2 values, store them.
            int[] s = stack;
            int p = pos;
            if ((uint)(p + 1) < (uint)s.Length)
            {
                s[p] = arg0;
                s[p + 1] = arg1;
                pos += 2;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0, arg1);
        
            // <summary>Resize the backtracking stack array and push 2 values onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0, int arg1)
            {
                Array.Resize(ref stack, (pos + 1) * 2);
                StackPush(ref stack, ref pos, arg0, arg1);
            }
        }
    }
}
